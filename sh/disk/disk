#! /bin/bash

disk() {
    _disk_path() {
        case "$1" in
            /dev/*) echo "$1";;
            *) echo "/dev/$1";;
        esac
    }

    _disk_best_format() {
        local disk="$1"
        local tran type model
        tran=$(lsblk -dn -o TRAN "$disk" 2>/dev/null)
        type=$(lsblk -dn -o TYPE "$disk" 2>/dev/null)
        model=$(lsblk -dn -o MODEL "$disk" 2>/dev/null | tr '[:upper:]' '[:lower:]')
        if [[ "$tran" =~ "" ]]; then
            echo "ext4"
        elif [[ "$tran" =~ "usb" || "$model" =~ "card" ]]; then
            echo "exfat"
        else
            echo "ext4"
        fi
    }

    if [[ "$1" == "list" ]]; then
        lsblk -d -o NAME,SIZE,TYPE,MODEL -e7

    elif [[ "$1" == "info" && -n "$2" ]]; then
        dev=$(_disk_path "$2")
        lsblk --json -o NAME,PATH,SIZE,TYPE,MOUNTPOINTS,UUID,FSTYPE,LABEL "$dev" | jq

    elif [[ ("$1" == "mnt" || "$1" == "mount") && -n "$2" ]]; then
        disk=$(_disk_path "$2")
        mnt="$3"
        if [[ -z "$mnt" ]]; then
            mnt="/mnt/$(basename "$disk")"
        fi
        mnt new "$disk" "$mnt"

    elif [[ ("$1" == "umnt" || "$1" == "umount") && -n "$2" ]]; then
        local mounted
        mounted=$(lsblk --json -o NAME,PATH,TYPE,MOUNTPOINTS | jq -r --arg HOME "$HOME" '
            .blockdevices[] as $dev
            | ([$dev] + ($dev.children // []))
            | .[]
            | select(.type == "part" or .type == "disk")
            | select(has("mountpoints") and (.mountpoints | type == "array"))
            | . as $part
            | $part.mountpoints[]?
            | select(type=="string" and (. | startswith("/mnt/") or startswith("/media/") or startswith($HOME)))
            | [ ($part.path // ("/dev/" + $part.name)), . ] | @tsv
        ')
        local found=0
        while read -r dev mp; do
            [[ "$2" == "$dev" || "$2" == "$mp" ]] && found=1 && break
        done <<< "$mounted"
        if [[ $found -eq 1 ]]; then
            mnt rm "$2"
        else
            echo "No matching mounted device or mountpoint: $2"
            return 1
        fi

    elif [[ "$1" == "format" && -n "$2" ]]; then
        disk=$(_disk_path "$2")
        shift 2
        local fs=""
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --format)
                    shift
                    fs="$1"
                    ;;
            esac
            shift
        done

        if [[ -z "$fs" ]]; then
            fs=$(_disk_best_format "$disk")
            echo "No --format given, will use: $fs"
        fi

        echo "WARNING: This will erase all data on $disk. Continue? [y/N]"
        read -r confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            case "$fs" in
                mfat|vfat|fat|fat32) sudo mkfs.vfat "$disk";;
                exfat) sudo mkfs.exfat "$disk";;
                ext4) sudo mkfs.ext4 "$disk";;
                ext3) sudo mkfs.ext3 "$disk";;
                ext2) sudo mkfs.ext2 "$disk";;
                ntfs) sudo mkfs.ntfs "$disk";;
                xfs) sudo mkfs.xfs "$disk";;
                *) echo "Unsupported filesystem: $fs"; return 1;;
            esac
        else
            echo "Cancelled."
        fi

    elif [[ "$1" == "scan" && -n "$2" ]]; then
        disk=$(_disk_path "$2")
        echo "Scanning $disk for errors (read-only)..."
        if command -v smartctl >/dev/null 2>&1; then
            sudo smartctl -a "$disk"
        else
            echo "smartctl not available, trying fsck..."
        fi

        if [[ -b "$disk" ]]; then
            if [[ "$disk" =~ [0-9]$ ]]; then
                sudo fsck -N "$disk"
            else
                echo "Hint: Scanning all partitions of $disk:"
                lsblk -ln -o PATH,FSTYPE "$disk" | while read part fstype; do
                    [[ "$part" == "$disk" ]] && continue
                    if [[ -z "$fstype" || "$fstype" == "iso9660" ]]; then
                        echo "  $part: Skipping (no filesystem or iso9660)"
                        continue
                    fi
                    echo "  $part ($fstype):"
                    sudo fsck -N "$part"
                done
            fi
        else
            echo "Not a valid block device: $disk"
        fi

    elif [[ "$1" == "recover" && -n "$2" ]]; then
        disk=$(_disk_path "$2")
        echo "Attempting to recover filesystem on $disk..."
        if [[ -b "$disk" ]]; then
            if [[ "$disk" =~ [0-9]$ ]]; then
                echo "Trying fsck with automatic repair for $disk:"
                sudo fsck -y "$disk"
            else
                echo "Trying fsck with automatic repair for ALL partitions of $disk:"
                lsblk -ln -o PATH,FSTYPE "$disk" | while read part fstype; do
                    [[ "$part" == "$disk" ]] && continue
                    if [[ -z "$fstype" || "$fstype" == "iso9660" ]]; then
                        echo "  $part: Skipping (no filesystem or iso9660)"
                        continue
                    fi
                    echo "  $part ($fstype):"
                    sudo fsck -y "$part"
                done
            fi
        else
            echo "Not a valid block device: $disk"
        fi

    else
        echo "Usage:"
        echo "  disk list"
        echo "  disk info <disk>"
        echo "  disk mnt|mount <disk> [mountpoint]"
        echo "  disk umnt|umount <disk>|<mountpoint>"
        echo "  disk format <disk> [--format <ext4|exfat|mfat|...>]"
        echo "  disk scan <disk>"
        echo "  disk recover <disk>"
        return 1
    fi
}

_disk_complete() {
    local cur prev subcmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    subcmd="${COMP_WORDS[1]}"

    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "list info mount umount format scan recover" -- "$cur") )
        return 0
    fi

    case "$subcmd" in
        info|mnt|mount|scan|recover)
            local devs
            devs=$(lsblk -dn -o NAME | sed 's|^|/dev/|')
            COMPREPLY=( $(compgen -W "$devs" -- "$cur") )
            ;;

        umnt|umount)
            local mount_list devs
            mount_list=$(lsblk --json -o NAME,PATH,TYPE,MOUNTPOINTS | jq -r --arg HOME "$HOME" '
                .blockdevices[] as $dev
                | ([$dev] + ($dev.children // []))
                | .[]
                | select(.type == "part" or .type == "disk")
                | select(has("mountpoints") and (.mountpoints | type == "array"))
                | . as $part
                | $part.mountpoints[]?
                | select(type=="string" and (. | startswith("/mnt/") or startswith("/media/") or startswith($HOME)))
                | [($part.path // ("/dev/" + $part.name)), .] | @tsv
            ')
            devs=$(echo "$mount_list" | awk '{print $1" "$2}')
            COMPREPLY=( $(compgen -W "$devs" -- "$cur") )
            ;;

        format)
            if [[ $COMP_CWORD -eq 2 ]]; then
                # Device complete
                local devs
                devs=$(lsblk -dn -o NAME | sed 's|^|/dev/|')
                COMPREPLY=( $(compgen -W "$devs" -- "$cur") )
            else
                for ((i=2; i < COMP_CWORD; i++))
                do
                    if [[ "${COMP_WORDS[$i]}" == "--format" ]]; then
                        if [[ $((i+1)) -eq $COMP_CWORD ]]; then
                            COMPREPLY=( $(compgen -W "ext4 ext3 ext2 mfat vfat fat exfat ntfs xfs" -- "$cur") )
                            return 0
                        fi
                    fi
                done
                if [[ "$cur" == --* ]]; then
                    COMPREPLY=( $(compgen -W "--format" -- "$cur") )
                fi
            fi
            ;;
    esac
}
complete -F _disk_complete disk
